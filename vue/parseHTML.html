<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <div id="div">
     <span>1</span>
     <img src="123">
  </div>
  <script>
    var div= document.getElementById('div');
    parseHTML(div.innerHTML)
      function parseHTML(
        html, //字符串模板
        options //参数
    ) {
        var stack = []; // parseHTML 节点标签堆栈
        var expectHTML = options.expectHTML; //true
        var isUnaryTag$$1 = options.isUnaryTag || no; //函数匹配标签是否是 'area,base,br,col,embed,frame,hr,img,input,isindex,keygen, link,meta,param,source,track,wbr'
        var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no; //函数 //判断标签是否是 'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
        var index = 0;
        var last, //
            lastTag; //
        console.log(html)



        while (html) { //循环html
            last = html; //
            // Make sure we're not in a plaintext content element like script/style 确保我们不在像脚本/样式这样的纯文本内容元素中
            if (
                !lastTag || //lastTag 不存在
                !isPlainTextElement(lastTag)  // 如果标签不是script,style,textarea
                ) {

                                                var textEnd = html.indexOf('<'); //匹配开始标签或者结束标签的位置
                                                if (textEnd === 0) { //标识是开始标签
                                                                    // Comment:
                                                                    if (comment.test(html)) { //匹配 开始字符串为<!--任何字符串,注释标签  如果匹配上
                                                                                        var commentEnd = html.indexOf('-->'); //获取注释标签的结束位置

                                                                                        if (commentEnd >= 0) { //如果注释标签结束标签位置大于0，则有注释内容
                                                                                                            console.log(html.substring(4, commentEnd))
                                                                                                            if (options.shouldKeepComment) { //shouldKeepComment为真时候。获取注释标签内容

                                                                                                                //截取注释标签的内容
                                                                                                                options.comment(html.substring(4, commentEnd));
                                                                                                            }
                                                                                                            //截取字符串重新循环  while 跳出循环就是靠该函数，每次匹配到之后就截取掉字符串，知道最后一个标签被截取完没有匹配到则跳出循环
                                                                                                            advance(commentEnd + 3);
                                                                                                            continue
                                                                                        }
                                                                    }

                                                                    //这里思路是先匹配到注释节点，在匹配到这里的ie浏览器加载样式节点
                                                                    // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                                                                    if (conditionalComment.test(html)) {  //匹配开始为 <![ 字符串  <![endif]-->   匹配这样动态加ie浏览器的 字符串  <!--[if IE 8]><link href="ie8only.css" rel="stylesheet"><![endif]-->
                                                                         //匹配ie浏览器动态加样式结束符号
                                                                        var conditionalEnd = html.indexOf(']>');

                                                                                                    if (conditionalEnd >= 0) {
                                                                                                        //截取字符串重新循环  while 跳出循环就是靠该函数，每次匹配到之后就截取掉字符串，知道最后一个标签被截取完没有匹配到则跳出循环
                                                                                                        advance(conditionalEnd + 2);
                                                                                                          continue
                                                                                                    }
                                                                    }

                                                                    // Doctype:
                                                                  //匹配html的头文件 <!DOCTYPE html>
                                                                    var doctypeMatch = html.match(doctype);
                                                                    if (doctypeMatch) {
                                                                        //截取字符串重新循环  while 跳出循环就是靠该函数，每次匹配到之后就截取掉字符串，知道最后一个标签被截取完没有匹配到则跳出循环
                                                                           advance(doctypeMatch[0].length);
                                                                          continue
                                                                    }

                                                                    // End tag:
                                                                    //匹配开头必需是</ 后面可以忽略是任何字符串  ^<\\/((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)[^>]*>
                                                                    var endTagMatch = html.match(endTag);
                                                                    if (endTagMatch) {

                                                                                        var curIndex = index;
                                                                                        //标签分隔函数 while 跳出循环就是靠该函数，每次匹配到之后就截取掉字符串，知道最后一个标签被截取完没有匹配到则跳出循环
                                                                                        advance(endTagMatch[0].length);
                                                                        console.log(endTagMatch)
                                                                        console.log(curIndex,index)
                                                                        //查找parseHTML的stack栈中与当前tagName标签名称相等的标签，
                                                                        //调用options.end函数，删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
                                                                        //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
                                                                                        parseEndTag(
                                                                                            endTagMatch[1],
                                                                                            curIndex,
                                                                                            index
                                                                                        );
                                                                                        continue
                                                                    }

                                                                    // Start tag:
                                                                     //解析开始标记 标记开始标签
                                                                  //  获取开始标签的名称，属性集合，开始位置和结束位置，并且返回该对象
                                                                    var startTagMatch = parseStartTag();

                                                                    if (startTagMatch) {
                                                                                        //把数组对象属性值循环变成对象，这样可以过滤相同的属性
                                                                                        //为parseHTML 节点标签堆栈 插入一个桟数据
                                                                                        //调用options.start  为parse函数 stack标签堆栈 添加一个标签
                                                                                        handleStartTag(startTagMatch);
                                                                                       //匹配tag标签是pre,textarea，并且第二个参数的第一个字符是回车键
                                                                                        if (shouldIgnoreFirstNewline(lastTag, html)) {
                                                                                                                              //去除回车键空格
                                                                                                                             advance(1);
                                                                                        }
                                                                                        continue
                                                                    }
                                                }

                                                var text = (void 0),
                                                    rest = (void 0),
                                                    next = (void 0);
                                                if (textEnd >= 0) {

                                                    rest = html.slice(textEnd); //截取字符串  var textEnd = html.indexOf('<'); //匹配开始标签或者结束标签的位置
                                                  console.log(rest)

                                                    while (
                                                                !endTag.test(rest) && //匹配开头必需是</ 后面可以忽略是任何字符串
                                                                !startTagOpen.test(rest) && // 匹配开头必需是< 后面可以忽略是任何字符串
                                                                !comment.test(rest) && // 匹配 开始字符串为<!--任何字符串
                                                                !conditionalComment.test(rest) //匹配开始为 <![ 字符串
                                                           ) {
                                                        console.log(rest);


                                                                    // < in plain text, be forgiving and treat it as text
                                                                // <在纯文本中，要宽容，把它当作文本来对待
                                                                    next = rest.indexOf('<', 1); //匹配是否有多个<
                                                                    if (next < 0) {
                                                                        break
                                                                    }
                                                                    textEnd += next; //截取 索引位置
                                                                    rest = html.slice(textEnd); //获取 < 字符串 <    获取他们两符号< 之间的字符串
                                                             }
                                                            text = html.substring(0, textEnd); //截取字符串 前面字符串到 <

                                                    //while 跳出循环就是靠该函数，每次匹配到之后就截取掉字符串，知道最后一个标签被截取完没有匹配到则跳出循环
                                                       advance(textEnd);
                                                }

                                                if (textEnd < 0) { //都没有匹配到 < 符号 则表示纯文本
                                                    text = html; //出来text
                                                    html = ''; //把html至空 跳槽 while循环
                                                }

                                                if (options.chars && text) {
                                                    options.chars(text);
                                                }
            } else {
                //  处理是script,style,textarea
                        var endTagLength = 0;
                        var stackedTag = lastTag.toLowerCase();
                        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
                        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
                                                                                            endTagLength = endTag.length;
                                                                                            if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
                                                                                                                                    text = text
                                                                                                                                                .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
                                                                                                                                                .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                                                                                            }
                                                                                             //匹配tag标签是pre,textarea，并且第二个参数的第一个字符是回车键
                                                                                            if (shouldIgnoreFirstNewline(stackedTag, text)) {
                                                                                                                                    text = text.slice(1);
                                                                                            }
                                                                                            if (options.chars) {
                                                                                                                                      options.chars(text);
                                                                                            }
                                                                                            return ''
                        });
                        index += html.length - rest$1.length;
                        html = rest$1;
                        parseEndTag(stackedTag, index - endTagLength, index);
            }

            if (html === last) {
                                    options.chars && options.chars(html);
                                    if ("development" !== 'production' && !stack.length && options.warn) {
                                                             options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
                                    }
                                    break
            }
        }






        // Clean up any remaining tags
        //查找parseHTML的stack栈中与当前tagName标签名称相等的标签，
        //调用options.end函数，删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
        //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
        parseEndTag();
         //while 跳出循环就是靠该函数，每次匹配到之后就截取掉字符串，知道最后一个标签被截取完没有匹配到则跳出循环
        function advance(n) {
            index += n; //让索引叠加
            html = html.substring(n); //截取当前索引 和 后面的字符串。
        }

        //获取开始标签的名称，收集属性集合，开始位置和结束位置，并且返回该对象
        function parseStartTag() {
            var start = html.match(startTagOpen); //匹配开始标签 匹配开头必需是< 后面可以忽略是任何字符串  ^<((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)
            console.log(start)
            console.log(start[0].length)

            if (start) {
                var match = {
                    tagName: start[1], //标签名称
                    attrs: [], //标签属性集合
                    start: index //标签的开始索引
                };
                //标记开始标签的位置，截取了开始标签
                advance(start[0].length);
                var end, attr;

                while (
                        !(end = html.match(startTagClose)) //没有到 关闭标签 > 标签
                        && (attr = html.match(attribute)) //收集属性
                       ) {
                    console.log(html)
                     //截取属性标签
                    advance(attr[0].length);
                    match.attrs.push(attr); //把属性收集到一个集合
                }
                if (end) {
                    match.unarySlash = end[1]; //如果是/>标签 则unarySlash 是/。 如果是>标签 则unarySlash 是空
                    console.log(end)

                    //截取掉开始标签，并且更新索引
                    advance(end[0].length);
                    match.end = index; //开始标签的结束位置
                    return match
                }
            }
        }

         //把数组对象属性值循环变成对象，这样可以过滤相同的属性
         //为parseHTML 节点标签堆栈 插入一个桟数据
        //调用options.start  为parse函数 stack标签堆栈 添加一个标签
        function handleStartTag(match) {
            /*
            * match = {
                     tagName: start[1], //标签名称
                     attrs: [], //标签属性集合
                     start: index， //开始标签的开始索引
                     match:index ，   //开始标签的 结束位置
                    unarySlash:'' //如果是/>标签 则unarySlash 是/。 如果是>标签 则unarySlash 是空
             };
            * */

            var tagName = match.tagName; //开始标签名称
            var unarySlash = match.unarySlash; //如果是/>标签 则unarySlash 是/。 如果是>标签 则unarySlash 是空
           console.log(expectHTML)
            console.log('lastTag==')
            console.log(lastTag)
            console.log(tagName)

            if (expectHTML) {   //true

                if (
                    lastTag === 'p' //上一个标签是p
                    /*
                      判断标签是否是
                     'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
                     'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
                     'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
                     'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
                     'title,tr,track'
                     */
                    && isNonPhrasingTag(tagName)
                ) {
                    //查找parseHTML的stack栈中与当前tagName标签名称相等的标签，
                    //调用options.end函数，删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
                    //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
                    parseEndTag(lastTag);
                }
                if (
                    canBeLeftOpenTag$$1(tagName) &&   //判断标签是否是 'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
                    lastTag === tagName //上一个标签和现在标签相同  <li><li> 编译成 <li></li>  但是这种情况是不会出现的 因为浏览器解析的时候会自动补全如果是<li>我是li标签<li> 浏览器自动解析成  <li>我是li标签</li><li> </li>
                ) {
                    //查找parseHTML的stack栈中与当前tagName标签名称相等的标签，
                    //调用options.end函数，删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
                    //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
                    parseEndTag(tagName);
                }
            }

            var unary = isUnaryTag$$1(tagName) || //函数匹配标签是否是 'area,base,br,col,embed,frame,hr,img,input,isindex,keygen, link,meta,param,source,track,wbr'
                         !!unarySlash; //如果是/> 则为真

            var l = match.attrs.length;
            var attrs = new Array(l); //数组属性对象转换正真正的数组对象
            for (var i = 0; i < l; i++) {
                var args = match.attrs[i]; //获取属性对象
                // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
                //对FF bug进行黑客攻击:https://bugzilla.mozilla.org/show_bug.cgi?id=369778
                if (
                    IS_REGEX_CAPTURING_BROKEN &&  //这个应该是 火狐浏览器私有 标志
                    args[0].indexOf('""') === -1
                ) {
                    if (args[3] === '') {
                        delete args[3];
                    }
                    if (args[4] === '') {
                        delete args[4];
                    }
                    if (args[5] === '') {
                        delete args[5];
                    }
                }
                var value = args[3] || args[4] || args[5] || '';
                var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
                    ? options.shouldDecodeNewlinesForHref  // true chrome在a[href]中编码内容
                    : options.shouldDecodeNewlines;  //flase //IE在属性值中编码换行，而其他浏览器则不会

                attrs[i] = {  //把数组对象属性值循环变成对象，这样可以过滤相同的属性
                    name: args[1], //属性名称
                    //属性值
                    value: decodeAttr(value, shouldDecodeNewlines) //替换html 中的特殊符号，转义成js解析的字符串,替换 把   &lt;替换 <  ， &gt; 替换 > ， &quot;替换  "， &amp;替换 & ， &#10;替换\n  ，&#9;替换\t

                };

            }

            console.log('==!unary==')
            console.log(!unary)

            if (!unary) { //如果不是单标签

                // 为parseHTML 节点标签堆栈 插入一个桟数据
                stack.push({ //标签堆栈
                    tag: tagName, //开始标签名称
                    lowerCasedTag: tagName.toLowerCase(), //变成小写记录标签
                    attrs: attrs //获取属性
                });
                //设置结束标签
                lastTag = tagName;
                console.log('== parseHTML handleStartTag stack==')
                console.log(stack)

            }


            //
            if (options.start) {

                //标签开始函数， 创建一个ast标签dom，  判断获取v-for属性是否存在如果有则转义 v-for指令 把for，alias，iterator1，iterator2属性添加到虚拟dom中
                //获取v-if属性，为el虚拟dom添加 v-if，v-eles，v-else-if 属性
                //获取v-once 指令属性，如果有有该属性 为虚拟dom标签 标记事件 只触发一次则销毁
                //校验属性的值，为el添加muted， events，nativeEvents，directives，  key， ref，slotName或者slotScope或者slot，component或者inlineTemplate 标志 属性
                // 标志当前的currentParent当前的 element
                //为parse函数 stack标签堆栈 添加一个标签
                options.start(
                    tagName,  //标签名称
                    attrs,  //标签属性
                    unary,  // 如果不是单标签则为真
                    match.start,  //开始标签的开始位置
                    match.end //开始标签的结束的位置
                );
            }


        }



         //查找parseHTML的stack栈中与当前tagName标签名称相等的标签，
        //调用options.end函数，删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
        //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
        function parseEndTag(
            tagName,   //标签名称
            start,  //结束标签开始位置
            end    //结束标签结束位置
        ) {
            var pos,
                lowerCasedTagName;
            if (start == null) { //如果没有传开始位置
                start = index;    //就那当前索引
            }
            if (end == null) {  //如果没有传结束位置
                end = index;    //就那当前索引
            }

            if (tagName) { //结束标签名称
                lowerCasedTagName = tagName.toLowerCase(); //将字符串转化成小写
            }

            // Find the closest opened tag of the same type 查找最近打开的相同类型的标记
            if (tagName) {
                // 获取stack堆栈最近的匹配标签
                for (pos = stack.length - 1; pos >= 0; pos--) {
                     //找到最近的标签相等
                    if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                        break
                    }
                }
            } else {
                // If no tag name is provided, clean shop
                //如果没有提供标签名称，请清理商店
                pos = 0;
            }


            if (pos >= 0) { //这里就获取到了stack堆栈的pos索引
                // Close all the open elements, up the stack 关闭所有打开的元素，向上堆栈
                console.log(pos)

                for (var i = stack.length - 1; i >= pos; i--) {

                                    if ("development" !== 'production' && //如果stack中找不到tagName 标签的时候就输出警告日志，找不到标签
                                        (i > pos || !tagName) &&
                                        options.warn
                                    ) {
                                        options.warn(
                                            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
                                        );
                                    }
                                    if (options.end) {
                                        console.log(options.end)
                                    //调用options.end函数，删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
                                     //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
                                        options.end(
                                            stack[i].tag,//结束标签名称
                                            start, //结束标签开始位置
                                            end //结束标签结束位置
                                        );
                                    }
                }
                // Remove the open elements from the stack
                //从堆栈中删除打开的元素
                // console.log(stack[pos].tag)
                // 为parseHTML 节点标签堆栈 出桟当前匹配到的标签
                stack.length = pos;
                //获取到上一个标签，就是当前节点的父节点
                lastTag = pos && stack[pos - 1].tag;
                console.log(stack)
                console.log(lastTag)




            } else if (lowerCasedTagName === 'br') {
                                                    if (options.start) {
                                                        //标签开始函数， 创建一个ast标签dom，  判断获取v-for属性是否存在如果有则转义 v-for指令 把for，alias，iterator1，iterator2属性添加到虚拟dom中
                                                        //获取v-if属性，为el虚拟dom添加 v-if，v-eles，v-else-if 属性
                                                        //获取v-once 指令属性，如果有有该属性 为虚拟dom标签 标记事件 只触发一次则销毁
                                                        //校验属性的值，为el添加muted， events，nativeEvents，directives，  key， ref，slotName或者slotScope或者slot，component或者inlineTemplate 标志 属性
                                                        // 标志当前的currentParent当前的 element
                                                        //为parse函数 stack标签堆栈 添加一个标签
                                                        options.start(
                                                            tagName,
                                                            [], true,
                                                            start,
                                                            end
                                                        );
                                                    }
            } else if (lowerCasedTagName === 'p') {
                                                if (options.start) {
                                                    //标签开始函数， 创建一个ast标签dom，  判断获取v-for属性是否存在如果有则转义 v-for指令 把for，alias，iterator1，iterator2属性添加到虚拟dom中
                                                    //获取v-if属性，为el虚拟dom添加 v-if，v-eles，v-else-if 属性
                                                    //获取v-once 指令属性，如果有有该属性 为虚拟dom标签 标记事件 只触发一次则销毁
                                                    //校验属性的值，为el添加muted， events，nativeEvents，directives，  key， ref，slotName或者slotScope或者slot，component或者inlineTemplate 标志 属性
                                                    // 标志当前的currentParent当前的 element
                                                    //为parse函数 stack标签堆栈 添加一个标签
                                                    options.start(
                                                        tagName,
                                                        [], false,
                                                        start,
                                                        end);
                                                }
                                                if (options.end) {
                                                    //删除当前节点的子节点中的最后一个如果是空格或者空的文本节点则删除，
                                                    //为stack出栈一个当前标签，为currentParent变量获取到当前节点的父节点
                                                    options.end(
                                                        tagName,
                                                        start,
                                                        end
                                                    );
                                                }
            }
            console.log(lastTag)

        }
    }
  </script>
</body>
</html>
